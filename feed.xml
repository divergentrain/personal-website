<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://sundar.guru/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sundar.guru/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-17T17:29:10+00:00</updated><id>https://sundar.guru/feed.xml</id><title type="html">Sundar Gurumurthy</title><subtitle>This is the personal website of Sundar Gurumurthy </subtitle><entry><title type="html">Why Rust Isn’t Ready for Engineering Software (Yet)</title><link href="https://sundar.guru/blog/2025/Rust-sucks-for-cae/" rel="alternate" type="text/html" title="Why Rust Isn’t Ready for Engineering Software (Yet)"/><published>2025-08-15T12:38:53+00:00</published><updated>2025-08-15T12:38:53+00:00</updated><id>https://sundar.guru/blog/2025/Rust-sucks-for-cae</id><content type="html" xml:base="https://sundar.guru/blog/2025/Rust-sucks-for-cae/"><![CDATA[<p>I wanted to develop a feature-rich, open-source CAE application in Rust. Easy memory safety <em>and</em> performance a tier above garbage-collected languages? Sign me up. Finally, a way to escape the data races and the tyranny of C++ compilers that think <code class="language-plaintext highlighter-rouge">"segmentation fault"</code> is an acceptable personality trait.</p> <p>I was ready to go all in — maybe even color my hair blue before writing my first lines in Rust. Rust seemed like my ticket to a modern, sane, productive development experience. Sure, I expected a few bumps along the way, but hey, Rust is supposed to make large projects <em>easy</em>, right? No big deal.</p> <p>Then I started looking for Rust packages and libraries to actually <em>build</em> my software… and the cracks appeared fast. The options were mostly half-finished <code class="language-plaintext highlighter-rouge">"work in progress"</code> crates or abandoned passion projects that haven’t seen a commit since the end of COVID-19 lock down.</p> <p>Need a CAD kernel like <a href="https://www.opencascade.com/">OpenCascade</a>? Nope. A meshing library like <a href="https://gmsh.info/">Gmsh</a>? Try again. A robust GUI toolkit like <a href="https://www.qt.io/">Qt</a>? Not unless you’re ready to wrap it yourself and pray it compiles.</p> <p>And then there’s integration with <strong>C++</strong> or <strong>Fortran</strong> code — the stuff where decades of CAE development already live. What’s the point of jumping through hoops for Rust’s memory safety if you have to bind it to massive, battle-scarred codebases that <em>don’t</em> provide that safety?</p> <p>It didn’t take long to realize my “options” in Rust were:</p> <ol> <li>Write every single library I need from scratch.</li> <li>Use <code class="language-plaintext highlighter-rouge">unsafe</code> bindings to the C++/Fortran libraries — completely defeating the whole point of using Rust in the first place.</li> </ol> <p>So instead of reinventing the wheel, I grabbed my trusty C++ toolkit and got back to writing actual code — because at least there, I can get work done without pretending my build system is a research project.</p> <p>Here’s why.</p> <hr/> <h2 id="1-interoperability-with-c-and-fortran-is-a-minefield">1. Interoperability With C++ and Fortran is a Minefield</h2> <p>Rust’s <code class="language-plaintext highlighter-rouge">FFI</code> works fine for plain C, but CAE libraries don’t live in a happy little C-shaped world. They live in C++ (templates, overloaded operators, inheritance) or Fortran (fresh hell arrays, anyone?).</p> <p>Wrapping these in Rust means:</p> <ul> <li>Writing hundreds of lines of <code class="language-plaintext highlighter-rouge">unsafe</code> glue code</li> <li>Losing half the API because the C++ parts are too complex to map</li> <li>Debugging segfaults that magically ignore Rust’s advertised memory safety</li> </ul> <p>Examples:</p> <ul> <li>Wrapping <a href="https://www.opencascade.com/">OpenCascade</a> for geometry modeling? Weeks of header wrangling.</li> <li>Calling <a href="https://petsc.org/">PETSc</a> or <a href="https://trilinos.github.io/">Trilinos</a> from Rust? Back to the C API — less functionality, worse performance.</li> </ul> <p>At that point, why not just write in C++ or Fortran?</p> <hr/> <h2 id="2-mpi-and-hpc-support-still-stuck-in-hobby-mode">2. MPI and HPC Support: Still Stuck in Hobby Mode</h2> <p>Most CAE solvers run on clusters — <strong>MPI</strong> isn’t optional. Rust has <a href="https://github.com/rsmpi/rsmpi">rsmpi</a>, a thin wrapper over the C API, but:</p> <ul> <li>No idiomatic integration with Rust’s <code class="language-plaintext highlighter-rouge">async</code> model</li> <li>Spotty support for MPI-3 features like remote memory access and non-blocking collectives</li> <li>Minimal adoption on vendor-tuned compilers (<a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/mpi-library.html">Intel MPI</a>, <a href="https://docs.nersc.gov/development/parallel-programming/mpi/">Cray MPI</a>)</li> </ul> <p>Technically possible, practically painful.</p> <hr/> <h2 id="3-gpu-acceleration-brace-yourself">3. GPU Acceleration: Brace Yourself</h2> <p>Modern CAE codes rely heavily on GPUs. CUDA, OpenGL, DirectX, Vulkan — GPU integration in Rust is still “aspirational.”</p> <ul> <li>CUDA bindings (<a href="https://github.com/Rust-GPU/Rust-CUDA">rust-cuda</a>) are incomplete or lag NVIDIA releases</li> <li>HIP and SYCL support? Almost nonexistent</li> <li>Vendor math libraries like <a href="https://developer.nvidia.com/cublas">cuBLAS</a>, <a href="https://developer.nvidia.com/cusparse">cuSPARSE</a>, <a href="https://developer.nvidia.com/cufft">cuFFT</a> have no idiomatic Rust wrappers</li> </ul> <p>You can write GPU kernels in Rust — if you want to reinvent half the CUDA driver API in <code class="language-plaintext highlighter-rouge">unsafe</code>. At that point, C++ is simpler.</p> <hr/> <h2 id="4-missing-mature-geometry-meshing-and-visualization-libraries">4. Missing Mature Geometry, Meshing, and Visualization Libraries</h2> <p>CAE software is geometry and meshes. Rust’s ecosystem is sparse:</p> <ul> <li>No Rust-native equivalents to <a href="https://www.opencascade.com/">OpenCascade</a>, <a href="https://gmsh.info/">Gmsh</a>, or <a href="https://www.cgal.org/">CGAL</a></li> <li>No production-ready bindings for <a href="https://vtk.org/">VTK</a> or <a href="https://www.paraview.org/">ParaView</a></li> </ul> <p>Want cutting planes, mesh overlays, stress maps? Either code them yourself in <a href="https://wgpu.rs/">wgpu</a> or wrap a C++ library — back in <code class="language-plaintext highlighter-rouge">unsafe</code> land.</p> <hr/> <h2 id="5-large-scale-build--tooling-woes">5. Large-Scale Build &amp; Tooling Woes</h2> <p>CAE projects combine Fortran solvers, C++ kernels, and potentially Rust. <code class="language-plaintext highlighter-rouge">Cargo</code> is great, but:</p> <ul> <li>Poor integration with <a href="https://cmake.org/">CMake</a>, <a href="https://bazel.build/">Bazel</a>, and other multi-language systems</li> <li>Debugging mixed Rust/C++ stacks is awkward with <a href="https://www.sourceware.org/gdb/">gdb</a> or <a href="https://lldb.llvm.org/">lldb</a></li> <li>Profiling tools like <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html">Intel VTune</a> or <a href="https://www.arm.com/products/development-tools/server-and-hpc/arm-forge/map">Arm MAP</a> have weaker Rust support</li> </ul> <p>When your workflow is “fight the build system” instead of “write features,” productivity suffers.</p> <hr/> <h2 id="6-long-term-stability-and-industry-risk">6. Long-Term Stability and Industry Risk</h2> <p>CAE software often lasts 10–20 years. Rust’s ecosystem moves fast:</p> <ul> <li>Crates can break between releases</li> <li>No guarantee today’s “best” bindings will exist in five years</li> </ul> <p>Conservative CAE companies avoid constant rewrites. Stability matters more than novelty.</p> <hr/> <h2 id="7-a-hopeful-future">7. A Hopeful Future</h2> <p>Rust is growing. Rust still doesn’t have the production ready plug and play engineering libraries but it has seen rapid development in tools for building those libraries such as:</p> <ul> <li>Graphics: <a href="https://wgpu.rs/">wgpu</a>, <a href="https://github.com/ash-rs/ash">ash</a>, <a href="https://vulkano.rs/">vulkano</a></li> <li>Linear algebra: <a href="https://nalgebra.org/">nalgebra</a>, <a href="https://github.com/rust-ndarray/ndarray">ndarray</a></li> <li>Parallel computation: <a href="https://github.com/rayon-rs/rayon">rayon</a>, <a href="https://github.com/crossbeam-rs/crossbeam">crossbeam</a></li> <li>C API interop: <a href="https://rust-lang.github.io/rust-bindgen/">bindgen</a>, <a href="https://cxx.rs/">cxx</a></li> </ul> <p>The community is actively building engineering capabilities — much like Python’s growth in scientific computing. Python succeeded for ease of use but faltered in runtime performance, which is why C++ and Fortran still dominate CAE backends but Python has taken over a large chunk of the less intensive frontends and data processing APIs. But Rust could challenge or even upend C++ and Fortran in the coming decades thanks to its combination of safety and high performance.</p> <p>There are still some promising Rust projects that I am watching out for:</p> <ul> <li>A developing CAD kernel: <a href="https://github.com/ricosjp/truck?tab=readme-ov-file">Truck</a></li> <li>A good but not great GUI toolkit: <a href="https://gtk-rs.org/">gtk-rs</a></li> </ul> <p>Challenges remain in engineering-focused meshing libraries and Rust-native MPI support.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>Rust is exciting, safe, modern, and <em>fun</em>. But for CAE — where performance, interoperability, and mature ecosystems matter — it’s not ready.</p> <p>Today, serious CAE projects thrive in C++/Fortran. Rust may eventually become a viable alternative, but for now, the tooling and ecosystem aren’t there yet.</p>]]></content><author><name></name></author><category term="Simulation-tools,"/><category term="Programming"/><category term="CAE,"/><category term="Scientific-Computing,"/><category term="Rust,"/><category term="C++,"/><category term="HPC"/><summary type="html"><![CDATA[Why Rust isn’t yet ready for CAE software development, from library gaps to HPC and GPU limitations.]]></summary></entry><entry><title type="html">What I do &amp;amp; why</title><link href="https://sundar.guru/blog/2025/What-and-why/" rel="alternate" type="text/html" title="What I do &amp;amp; why"/><published>2025-06-21T00:00:00+00:00</published><updated>2025-06-21T00:00:00+00:00</updated><id>https://sundar.guru/blog/2025/What-and-why</id><content type="html" xml:base="https://sundar.guru/blog/2025/What-and-why/"><![CDATA[<h1 id="who-am-i">Who Am I</h1> <p>I would describe myself as a curious person—someone simply trying their best to explore and understand the world. Like anyone else, I make assumptions about people and places, but I’m always happy to be proven wrong. That just means I’ve learned something new.</p> <p>I was born and raised in India and currently live in the UK. But more than identifying with a country, I see myself as a citizen of the world. I’m always excited to meet new people and hear their stories—each life offering a perspective I might never have considered.</p> <hr/> <h1 id="what-i-do">What I Do</h1> <h2 id="i-love-to-learn">I Love to Learn</h2> <p>I’m easily drawn to anything that offers an opportunity to learn. Whether it’s a new hobby, a practical skill, or a deep dive into some obscure rabbit hole, I’m always looking to grow—even if just a little bit.</p> <p>How I learn changes all the time. Some days it’s documentaries or podcasts. Other days, it’s books or endless Wikipedia spirals. Whatever the medium, the goal is the same: to better understand myself and the world around me.</p> <h2 id="i-make-photos">I Make Photos</h2> <p>Photography is one of the ways I connect with the world. When I’m behind the camera—whether capturing nature, people, or everyday objects—I try to see things more clearly, more intimately.</p> <p>Photographing people, in particular, is a deeply vicarious experience. It allows me to momentarily step into someone else’s world, to better understand the lives that pass me by each day.</p> <p>I mostly shoot in London, with favorite spots like South Bank, Marsh Lane, Hyde Park, and Shoreditch. While I do share some of my work online, most of my photos are taken for myself—for the quiet joy of observing.</p> <p>I also enjoy looking at other people’s photography. I often visit photo exhibits in London galleries. I like to think of this as <em>nested vicariousness</em>: trying to experience what the photographer experienced as <em>they</em> tried to experience their subject.</p> <h2 id="i-like-to-fiddle-around">I Like to Fiddle Around</h2> <p>I have a natural tendency to tinker. If something piques my interest, I want to get my hands on it and figure out how it works. Most often, this curiosity leads me into the world of technology—especially software.</p> <p>From running my personal Linux servers to automating repetitive tasks at work, I’m always looking for ways to make things smoother, simpler, or just more interesting. This habit of “fiddling” has often led to some of my most impactful contributions at work—usually sparked by boredom and a desire to make life easier for myself and others.</p> <hr/>]]></content><author><name></name></author><category term="self"/><category term="life,"/><category term="philosophy"/><summary type="html"><![CDATA[A longer introduction about myself for those who have the time]]></summary></entry></feed>